#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#include <malloc.h>


//ƒаны m наборов, каждый из которых состоит из n чисел. ¬ каждом наборе можно переставл€ть цифры произвольным образом, получа€ при этом некоторое число.Ќеобходимо проверить, можно
//ли сформировать из этих наборов возрастающую последовательность чисел

void sortDigits(int* num, int n)
{
	for (int i = 0; i < n - 1; i++)
	{
		for (int j = 0; j < n - i - 1; j++)
		{
			if (num[j] > num[j + 1])
			{
				int temp = num[j];
				num[j] = num[j + 1];
				num[j + 1] = temp;
			}
		}
	}
} 

bool canFormIncreasingSequence(int** sets, int m, int n)
{
	for (int i = 0; i < m; i++)
	{
		sortDigits(sets[i], n);
	}
	int currentMin = sets[0][0];

	for (int i = 1; i < m; i++)
	{
		int j = 0;
		while (j < n && sets[i][j] <= currentMin)
		{
			j++;
		}
		if (j == n)
		{
			return false; 
		}
		currentMin = sets[i][j];
	}

	return true; 
}

int main()
{
	system("chcp 1251");
	int m, n;

	do {
		printf("¬ведите количество наборов (m): "); scanf("%d", &m);
	} while (m < 2);

	do {
		printf("¬ведите количество чисел в каждом наборе (n): "); scanf("%d", &n);
	} while (n < 2);

	int** sets = (int**)malloc(m * sizeof(int*));

	for (int i = 0; i < m; i++)
	{
		printf("¬ведите числа набора %d:\n", i + 1);
		sets[i] = (int*)malloc(n * sizeof(int));
		for (int j = 0; j < n; j++)
		{
			scanf("%d", &sets[i][j]);
		}
	}

	if (canFormIncreasingSequence(sets, m, n)) {
		printf("ћожно сформировать возрастающую последовательность.\n");
	}
	else {
		printf("Ќельз€ сформировать возрастающую последовательность.\n");
	}

	for (int i = 0; i < m; i++) {
		free(sets[i]);
	}
	free(sets);

	return 0;
}



//—ортировка цифр внутри каждого числа в каждом наборе: Ётот шаг включает в себ€ два вложенных цикла, где n - количество чисел в каждом наборе. 
//ѕоэтому сложность этого шага составл€ет O(m * n^2), где m - количество наборов, а n - количество чисел в каждом наборе.
//ѕроверка на возможность формировани€ возрастающей последовательности : Ётот шаг включает в себ€ один внешний цикл, который перебирает все наборы.
//¬нутри этого цикла выполн€етс€ еще один цикл, который перебирает числа внутри набора.—ложность этого шага составл€ет O(m* n), 
//где m - количество наборов, а n - количество чисел в каждом наборе.
//»тогова€ сложность алгоритма : O(m * n ^ 2 + m * n).
//јлгоритм имеет квадратичную сложность(O(n ^ 2)) от количества чисел внутри каждого набора и линейную сложность(O(m)) от количества наборов.
